# goweight 工具原理与使用指南

## 概述

goweight 是一个用于分析 Go 程序大小构成的工具，可以帮助开发者了解程序中各个包在最终二进制文件中所占用的空间，从而优化程序大小。

## 核心原理

### 1. 静态链接后分析（默认模式）

这是 goweight 的主要分析模式，通过分析最终的静态链接二进制文件来评估包大小：

 - **工作流程**：
   1. 使用 `go build` 构建项目，生成静态链接的二进制文件
   2. 使用 `debug/buildinfo` 包读取二进制文件中的构建信息
   3. 分析二进制文件的符号表来估算各包的大小
   4. 支持多种二进制格式（ELF、Mach-O、PE）

 - **特点**：
   - 反映最终二进制文件中各包的真实大小贡献
   - 经过链接器优化（死代码消除、符号压缩等）
   - 显示最终可执行文件中各包的占用空间

### 2. 二进制文件分析模式

分析已存在的二进制文件：

 - **工作流程**：
   1. 使用 `debug/buildinfo` 包读取二进制文件中的构建信息
   2. 解析符号表获取各包在二进制文件中的贡献
   3. 对于不同平台（ELF/Linux、Mach-O/macOS、PE/Windows）使用相应的解析方法
   4. 估算各包在二进制文件中的大小

 - **特点**：
   - 可以分析任意已存在的 Go 二进制文件
   - 反映运行时的实际大小
   - 经过链接器优化后的大小

### 3. 构建过程分析（实验性功能）

通过分析 Go 编译器的构建过程来了解各包的编译大小：

 - **工作流程**：
   1. 使用 `go build -work -a -x` 命令显示详细的构建过程
   2. 解析构建输出中的编译命令
   3. 注意：由于 Go 的临时工作目录机制，此模式目前仅能显示包名，无法获取实际大小

 - **特点**：
   - 显示构建过程中涉及的包
   - 由于 Go 的临时目录机制，无法获取实际文件大小

## 功能特性

### 1. 输出模式

 - **简略输出（默认）**：将相关的包进行聚合
   - `internal/*`：聚合所有 internal/ 开头的包
   - `github.com/user`：按用户名聚合 GitHub 包
   - `domain.com/project`：按项目聚合

 - **详细输出（-v 标志）**：显示所有单独的包，不进行聚合

 - **JSON 输出（-j 标志）**：输出机器可读的 JSON 格式

### 2. 平台支持

 - Linux (ELF 格式)
 - macOS (Mach-O 格式)
 - Windows (PE 格式)

## 使用方法

### 1. 静态链接后分析（默认）

```bash
# 分析当前项目（默认模式）
./goweight

# 分析特定包
./goweight ./cmd/yourapp

# 详细输出
./goweight -v

# JSON 输出
./goweight -j

# 使用构建标签
./goweight --tags="prod,debug"
```

### 2. 二进制文件分析

```bash
# 分析已存在的二进制文件
./goweight -b /path/to/binary

# 详细输出
./goweight -v -b /path/to/binary
```

### 3. 构建过程分析（实验性）

```bash
# 分析构建过程（实验性功能）
./goweight --build-analysis

# 对指定包进行构建过程分析
./goweight --build-analysis ./cmd/app
```

## 输出解读

### 静态链接后分析输出

```
284 kB github.com/thoas/go-funk
196 kB github.com/alecthomas/kingpin/v2
 66 kB github.com/dustin/go-humanize
 20 kB github.com/xhit/go-str2duration/v2
  0 B github.com/jondot/goweight
```

 - 显示最终二进制文件中各包的实际占用
 - 经过链接器优化后的大小
 - 0 字节可能表示该包的代码被完全内联或优化掉了

### 二进制文件分析输出

与静态链接后分析类似，但针对已存在的二进制文件。

## 技术实现细节

### 1. 符号表分析

 - **ELF 文件**：使用 `debug/elf` 包解析符号表
 - **Mach-O 文件**：使用 `debug/macho` 包解析符号表
 - **PE 文件**：使用 `debug/pe` 包解析符号表

### 2. 包名提取

 - 从符号名中提取包路径
 - 处理 Go 特有的符号命名约定
 - 支持标准库、第三方库和自定义包

### 3. 大小估算

 - 直接从符号表获取大小信息（如果可用）
 - 基于符号数量和二进制文件总大小进行估算
 - 考虑不同平台的特性和限制

## 适用场景

 1. **性能优化**：识别占用空间较大的包
 2. **依赖管理**：了解各依赖包的大小贡献
 3. **部署优化**：减少可执行文件大小
 4. **代码审查**：发现不必要的大型依赖
 5. **CI/CD 集成**：监控二进制文件大小变化

## 注意事项

 1. **标准库分析**：由于 Go 编译器的优化，标准库的大小可能不会在最终二进制文件中明确分离
 2. **构建过程分析限制**：由于 Go 的临时工作目录机制，实验性的构建过程分析功能目前无法显示实际文件大小
 3. **符号表依赖**：二进制文件分析依赖于符号表信息，如果编译时去除了符号表，分析精度会降低
 4. **交叉编译**：分析结果可能受编译目标平台影响
 5. **不同分析模式结果差异**：静态链接后分析和构建分析的结果可能不同，因为前者经过了链接器优化

通过 goweight，开发者可以深入了解 Go 程序的大小构成，从而做出更好的架构决策和优化选择。